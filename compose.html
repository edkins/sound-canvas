<html>
	<head>
		<meta charset="utf-8">
	</head>
	<script>
'use strict';
const f_hz = 440 * Math.pow(2, -4/12);
const mode_names = ['Lyd.','Major','Mix.','Dor.','Minor','Phr.'];
const note_names = ['C♭','G♭','D♭','A♭','E♭','B♭','F','C','G','D','A','E','B','F♯','C♯','G♯','D♯','A♯','E♯'];
const lyd_scale_fifths = [0, 2, 4, 6, 1, 3, 5];
let key_sig = undefined;
let key_mode = undefined;
const max_pitch = 48;

let key_pat = 8;
const scale_defs = [
	{
		name: 'Pentatonic',
		pitches: [0, 2, 4, 7, 9],
		modes: ['Pent maj','Pent sus','Blues min','Blues maj','Pent min'],
	},
	{
		name: 'Hexatonic',
		pitches: [0, 2, 4, 5, 7, 9],
		modes: ['Hex maj','Hex min','?','?','?','?'],
	},
	{
		name: 'Hex blues',
		pitches: [0, 2, 4, 6, 7, 9],
		modes: ['?','?','?','?','?','Hex blues'],
	},
	{
		name: 'Aug',
		pitches: [0, 3, 4, 7, 8, 11],
		modes: ['Aug','?','Aug','?','Aug','?'],
	},
	{
		name: 'Whole tone',
		pitches: [0, 2, 4, 6, 8, 10],
		modes: ['Whole tone','Whole tone','Whole tone','Whole tone','Whole tone','Whole tone'],
	},
	{
		name: 'Prometheus',
		pitches: [0, 2, 4, 7, 8, 10],
		modes: ['?','?','?','?','?','Prometheus'],
	},
	{
		name: 'Tritone',
		pitches: [0, 1, 4, 6, 7, 10],
		modes: ['Tritone','?','?','Tritone','?','?'],
	},
	{
		name: 'Two semitone tritone',
		pitches: [0, 1, 2, 6, 7, 8],
		modes: ['2ST Tritone','?','?','2ST Tritone','?','?'],
	},
	{
		name: 'Diatonic',
		pitches: [0, 2, 4, 5, 7, 9, 11],
		modes: ['Major','Dorian','Phrygian','Lydian','Mixolydian','Minor','Locrian']
	},
	{
		name: 'Melodic',
		pitches: [0, 2, 3, 5, 7, 9, 11],
		modes: ['Mel minor','Phrygian ♮6','Lydian aug','Acoustic','Mel major','Half dimin','Altered'],
	},
	{
		name: 'Harmonic maj',
		pitches: [0, 2, 4, 5, 7, 8, 11],
		modes: ['Harmon maj','Dorian ♭5','Phrygian ♭4','Lydian ♭3','Mix ♭2','Lyd Aug ♯2','Locrian 𝄫7'],
	},
	{
		name: 'Harmonic min',
		pitches: [0, 2, 4, 5, 8, 9, 11],
		modes: ['?','Ukr Dorian','Phryg dom','?','?','Harmon min','?'],
	},
	{
		name: 'Double harmonic',
		pitches: [0, 1, 4, 5, 7, 8, 11],
		modes: ['Dbl harmon','Lyd♯2♯6','Ultraphryg','Hung minor','Oriental','Ionian♯2♯6','Locrian𝄫3𝄫7'],
	},
	{
		name: 'Neapolitan min',
		pitches: [0, 3, 4, 5, 7, 9, 11],
		modes: ['Neap min','?','?','Lyd min','?','?','?'],
	},
	{
		name: 'Neapolitan maj',
		pitches: [0, 1, 3, 5, 7, 9, 11],
		modes: ['Neap maj','?','?','?','Major Loc','?','?'],
	},
	{
		name: 'Enigmatic asc',
		pitches: [0, 1, 2, 5, 7, 9, 11],
		modes: ['?','Enig asc','?','?','?','?','?'],
	},
	{
		name: 'Enigmatic desc',
		pitches: [0, 1, 2, 5, 8, 9, 11],
		modes: ['?','Enig desc','?','?','?','?','?'],
	},
	{
		name: 'Octatonic',
		pitches: [0, 2, 3, 5, 6, 8, 9, 11],
		modes: ['WS/HS dim','Octatonic','WS/HS dim','Octatonic','WS/HS dim','Octatonic','WW/HS dim','Octatonic'],
	},
	{
		name: 'Bebop',
		pitches: [0, 2, 4, 5, 6, 7, 9, 11],
		modes: ['?','Bebop Dor','?','?','?','Bebop dom','?','?'],
	},
	{
		name: 'Bebop alt',
		pitches: [0, 1, 2, 4, 5, 7, 9, 11],
		modes: ['?','?','Alt Bb Dor','?','?','?','?','?'],
	},
	{
		name: 'Bebop harmonic',
		pitches: [0, 2, 4, 5, 7, 8, 9, 11],
		modes: ['Bebop maj','?','?','?','?','?','Bb har min','?'],
	},
	{
		name: 'Bebop melod',
		pitches: [0, 2, 3, 5, 7, 8, 9, 11],
		modes: ['Bb mel min','?','?','?','?','?','?','?'],
	},
	{
		name: 'Alex',
		pitches: [0, 1, 3, 4, 5, 7, 8, 9],
		modes: ['?','?','?','?','?','?','Alex','?'],
	},
	{
		name: 'Blues9',
		pitches: [0, 2, 3, 4, 5, 7, 9, 10, 11],
		modes: ['Blues9','?','?','?','?','?','?','?','?'],
	},
	{
		name: 'Chromatic',
		pitches: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
		modes: ['Chr','Chr','Chr','Chr','Chr','Chr','Chr','Chr','Chr','Chr','Chr','Chr'],
	}
];

function box(svg, x, y, w, h, fill, label) {
	return multibox(svg, x, y, w, h, fill, [{label,x:0,y:0}]);
}

function multibox(svg, x, y, w, h, fill, labels) {
	const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
	rect.setAttribute('x', x);
	rect.setAttribute('y', y);
	rect.setAttribute('width', w);
	rect.setAttribute('height', h);
	rect.setAttribute('fill', fill);
	rect.setAttribute('stroke', '#000');
	svg.appendChild(rect);

	for (const label of labels) {
		const text = document.createElementNS('http://www.w3.org/2000/svg','text');
		text.setAttribute('x', x + w / 2 + label.x);
		text.setAttribute('y', y + h / 2 + label.y);
		text.setAttribute('dominant-baseline', 'central');
		text.setAttribute('text-anchor', 'middle');
		text.setAttribute('fill', '#000');
		text.setAttribute('pointer-events', 'none');
		text.textContent = label.label;
		svg.appendChild(text);
	}

	return rect;
}

// sorry these are so ugly

/*
function scale_note_name(sig, mode, n) {
	let n_mod7 = ((n + (4 * mode) % 7) + 7) % 7;
	return note_names[6 + sig + lyd_scale_fifths[n_mod7]];
}

function scale_note_pitch(sig, mode, n) {
	let n_mod7 = ((n + (4 * mode) % 7) + 7) % 7;
	let t_mod7 = ((0 + (4 * mode) % 7) + 7) % 7;
	let pitch_class = (12 + (sig + lyd_scale_fifths[n_mod7]) * 7) % 12;
	let t_class     = (12 + (sig + lyd_scale_fifths[t_mod7]) * 7) % 12;
	let octave = Math.floor((n + 0.01) / 7);
	if (t_class > pitch_class) {
		octave++;
	}
	return pitch_class + octave * 12;
}
*/

function mod(a,b) {
	return ((a % b) + b) % b;
}

function div(a,b) {
	return Math.round((a - mod(a,b)) / b);
}

function full_key_name(pat, sig, mode) {
	let mode_name = scale_defs[pat].modes[mode];
	if (mode_name === '?') {
		mode_name = scale_defs[pat].name + '?' + mode;
	}
	return scale_note_name(pat, sig, mode, 0).name + ' ' + mode_name;
}

function scale_chord_quality(pat, mode, n) {
	let scale_len = scale_defs[pat].pitches.length;
	let mode_nclass = mod(mode + n, scale_len);
	let pitch_class = scale_defs[pat].pitches[mode_nclass];

	let fifth_class = mod(pitch_class + 7, 12);
	let minor_third_class = mod(pitch_class + 3, 12);
	let major_third_class = mod(pitch_class + 4, 12);

	const fifth = scale_defs[pat].pitches.indexOf(fifth_class) !== -1;
	const minor_third = scale_defs[pat].pitches.indexOf(minor_third_class) !== -1;
	const major_third = scale_defs[pat].pitches.indexOf(major_third_class) !== -1;

	if (fifth && major_third && minor_third) {
		return 'both';
	} else if (fifth && major_third) {
		return 'major';
	} else if (fifth && minor_third) {
		return 'minor';
	} else {
		return undefined;
	}
}

function scale_note_pitch(pat, sig, mode, n) {
	let scale_len = scale_defs[pat].pitches.length;
	let base = mod(sig * 7, 12);
	let mode_nclass = mod(mode + n, scale_len);
	let octave = div(mode + n, scale_len);
	return base + scale_defs[pat].pitches[mode_nclass] + 12 * octave;
}

function scale_note_name(pat, sig, mode, n) {
	let scale_len = scale_defs[pat].pitches.length;
	let mode_nclass = mod(mode + n, scale_len);
	let pitch_class = mod(sig * 7 + scale_defs[pat].pitches[mode_nclass], 12);
	let prev_pitch_class = mod(sig * 7 + scale_defs[pat].pitches[mod(mode_nclass-1,scale_len)], 12);
	let next_pitch_class = mod(sig * 7 + scale_defs[pat].pitches[mod(mode_nclass+1,scale_len)], 12);

	const diatonic = [0, 2, 4, 5, 7, 9, 11];
	//                    0   1    2   3    4   5   6    7   8    9   10   11
	const names_sharp = ['C','C♯','D','D♯','E','F','F♯','G','G♯','A','A♯','B'];
	const names_flat  = ['C','D♭','D','E♭','E','F','G♭','G','A♭','A','B♭','B'];
	const class_sharp = [ 0,  0,   1,  1,   2,  3,  3,   4,  4,   5,  5,   6];
	const class_flat  = [ 0,  1 ,  1,  2,   2,  3,  4,   4,  5,   5,  6,   6];

	// Use the key signature to guide whether we should write it as a sharp or a flat
	// But if it's sandwiched between D and F, write it as E♭  not D♯
	let name = undefined;
	if (class_sharp[next_pitch_class] === class_flat[next_pitch_class] && class_sharp[next_pitch_class] === class_flat[pitch_class]) {
		name = names_sharp[pitch_class];
	} else if (class_sharp[prev_pitch_class] === class_flat[prev_pitch_class] && class_flat[prev_pitch_class] === class_sharp[pitch_class]) {
		name = names_flat[pitch_class];
	} else if (sig >= 0) {
		name = names_sharp[pitch_class];
	} else {
		name = names_flat[pitch_class];
	}

	let accidental = undefined;
	if (diatonic.indexOf(scale_defs[pat].pitches[mode_nclass]) === -1) {
		accidental = name;
		if (diatonic.indexOf(pitch_class) !== -1) {
			accidental += '♮';
		}
	}

	return {name, accidental};
}

function click_pattern(e) {
	key_pat = parseInt(e.target.dataset.pat);
	init_key_menu();
}

function init_key_menu() {
	const svg = document.getElementById('key-menu');
	while (svg.lastChild) {
		svg.removeChild(svg.lastChild);
	}

	let chosen_y = 0;
	for (let pat = 0; pat < scale_defs.length; pat++) {
		let fill = '#fff';
		const y = pat * 30;
		if (pat === key_pat) {
			fill = '#cff';
			chosen_y = y + 15;
		}
		const rect = box(svg, 0, y, 200, 30, fill, scale_defs[pat].name);
		rect.dataset.pat = pat;
		rect.onclick = click_pattern;
	}
	const tri = document.createElementNS('http://www.w3.org/2000/svg','polygon');
	tri.setAttribute('fill','#fff');
	tri.setAttribute('stroke','#000');
	tri.setAttribute('points',`200,${chosen_y} 280,0 280,${14*45}`);
	svg.appendChild(tri);
	

	const scale_len = scale_defs[key_pat].pitches.length;
	const x0 = 280;
	const w = 800 / (scale_len + 1);
	const h = 45;
	box(svg, x0, 0, w, h, '#fff', 'Key sig');
	for (let mode = 0; mode < scale_len; mode++) {
		const quality = scale_chord_quality(key_pat, mode, 0);
		let fill = '#fff';
		if (quality === 'both') {
			fill = '#f8c';
		} else if (quality === 'major') {
			fill = '#fdd';
		} else if (quality === 'minor') {
			fill = '#cdf';
		}
		let mode_name = '?';
		if (scale_defs[key_pat].modes !== undefined) {
			mode_name = scale_defs[key_pat].modes[mode];
		}
		box(svg, x0 + (mode + 1) * w, 0, w, h, fill, mode_name);
	}
	for (let sig = -6; sig <= 6; sig++) {
		let labels = [];
		const sharp_ys = [3, 0, 4, 1, -2, 2, -1];
		const flat_ys = [0, 3, -1, 2, -2, 1];
		for (let i = 0; i < Math.abs(sig); i++) {
			if (sig < 0) {
				labels.push({
					label: '♭',
					x: i * 8 - 20,
					y: -flat_ys[i] * 4
				});
			} else {
				labels.push({
					label: '♯',
					x: i * 8 - 20,
					y: -sharp_ys[i] * 4
				});
			}
			
		}
		multibox(svg, x0, (7 - sig) * h, w, h, '#fff', labels);

		for (let mode = 0; mode < scale_len; mode++) {
			let fill = '#fff';
			if (mode === key_mode && sig === key_sig) {
				fill = '#cff';
			} /*else if (mode === 1) {
				fill = '#fff4f4';
			} else if (mode === 4) {
				fill = '#f4f8ff';
			}*/
			let {name,accidental} = scale_note_name(key_pat, sig, mode, 0);
			if (accidental !== undefined) {
				fill = '#ccc';
			}
			let rect = box(svg, x0 + (mode + 1) * w, (7 - sig) * h, w, h, fill, name);
			rect.dataset.mode = mode;
			rect.dataset.sig = sig;
			rect.onclick = click_key;
		}
	}
}

function init_main() {
	const svg = document.getElementById('scale');
	const max_n = max_pitch + 12;  // should be enough labels
	for (let n = 0; n < max_n; n++) {
		const x = 0;
		
		const text = document.createElementNS('http://www.w3.org/2000/svg','text');
		text.setAttribute('x', x);
		text.setAttribute('y', 0); // set later
		text.setAttribute('font-size', 13);
		text.textContent = '';   // will be filled in later

		svg.appendChild(text);
	}
}

function init() {
	init_key_menu();
	init_main();
	update_display();
}

function update_display() {
	const key_menu = document.getElementById('key-menu');
	const main = document.getElementById('main');
	const scale = document.getElementById('scale');

	if (key_sig === undefined || key_mode === undefined) {
		key_menu.classList.remove('hidden');
		main.classList.add('hidden');
	} else {
		key_menu.classList.add('hidden');
		main.classList.remove('hidden');
		document.getElementById('key-name').textContent = 'Key: ' + full_key_name(key_pat, key_sig, key_mode);
		let text_index = 0;
		let texts = scale.getElementsByTagName('text');
		let n = -12;
		while (true) {
			const pitch = scale_note_pitch(key_pat, key_sig, key_mode, n);
			if (pitch >= max_pitch) {
				break;
			}
			if (pitch >= 0) {
				const text = texts[text_index];
				if (text === undefined) {
					break;
				}
				text_index++;
				const y = 750 - 13 * pitch;
				const label = scale_note_name(key_pat, key_sig, key_mode, n).name;
				text.setAttribute('y', y);
				text.textContent = label;
				text.classList.remove('hidden');
			}
			n++;
		}
		while (text_index < texts.length) {
			const text = texts[text_index];
			text.classList.add('hidden');
			text_index++;
		}
	}
}

function click_key(e) {
	key_mode = parseInt(e.target.dataset.mode);
	key_sig = parseInt(e.target.dataset.sig);
	update_display();
}

window.onload = init;

	</script>
<style>
.hidden {
	display: none;
}
</style>
	<body>
		<svg width="1200" height="750" style="background:#eee" id="svg">
			<g id="key-menu"/>
			<g id="main">
				<text id="key-name" x="0" y="20"></text>
				<g id="scale"/>
			</g>
		</svg>
	</body>
</html>
