<html>
	<head>
		<meta charset="utf-8">
	</head>
	<script>
'use strict';
const f_hz = 440 * Math.pow(2, -4/12);
const lyd_scale_fifths = [0, 2, 4, 6, 1, 3, 5];
let key_sig = undefined;
let key_mode = undefined;
const max_pitch = 48;
let current_chord = undefined;
let ctx = undefined;
let oscs = undefined;
let gains = undefined;
let silence_times = undefined;
let osc_pitches = undefined;
let max_osc_count = 0;
const c_hz = 440 * Math.pow(2, -9/12) / 2;
let events = [];
let playing = false;
let playing_time = 0;
let timer_handle = undefined;
const beats_per_chord = 4;
let current_chord_index = undefined;

let key_pat = 8;
const scale_defs = [
	{
		name: 'Pentatonic',
		pitches: [0, 2, 4, 7, 9],
		modes: ['Pent maj','Pent sus','Blues min','Blues maj','Pent min'],
	},
	{
		name: 'Hexatonic',
		pitches: [0, 2, 4, 5, 7, 9],
		modes: ['Hex maj','Hex min','?','?','?','?'],
	},
	{
		name: 'Hex blues',
		pitches: [0, 2, 4, 6, 7, 9],
		modes: ['?','?','?','?','?','Hex blues'],
	},
	{
		name: 'Aug',
		pitches: [0, 3, 4, 7, 8, 11],
		modes: ['Aug','?','Aug','?','Aug','?'],
	},
	{
		name: 'Whole tone',
		pitches: [0, 2, 4, 6, 8, 10],
		modes: ['Whole tone','Whole tone','Whole tone','Whole tone','Whole tone','Whole tone'],
	},
	{
		name: 'Prometheus',
		pitches: [0, 2, 4, 7, 8, 10],
		modes: ['?','?','?','?','?','Prometheus'],
	},
	{
		name: 'Tritone',
		pitches: [0, 1, 4, 6, 7, 10],
		modes: ['Tritone','?','?','Tritone','?','?'],
	},
	{
		name: 'Two semitone tritone',
		pitches: [0, 1, 2, 6, 7, 8],
		modes: ['2ST Tritone','?','?','2ST Tritone','?','?'],
	},
	{
		name: 'Diatonic',
		pitches: [0, 2, 4, 5, 7, 9, 11],
		modes: ['Major','Dorian','Phrygian','Lydian','Mixolydian','Minor','Locrian']
	},
	{
		name: 'Melodic',
		pitches: [0, 2, 3, 5, 7, 9, 11],
		modes: ['Mel minor','Phrygian â™®6','Lydian aug','Acoustic','Mel major','Half dimin','Altered'],
	},
	{
		name: 'Harmonic maj',
		pitches: [0, 2, 4, 5, 7, 8, 11],
		modes: ['Harmon maj','Dorian â™­5','Phrygian â™­4','Lydian â™­3','Mix â™­2','Lyd Aug â™¯2','Locrian ð„«7'],
	},
	{
		name: 'Harmonic min',
		pitches: [0, 2, 4, 5, 8, 9, 11],
		modes: ['?','Ukr Dorian','Phryg dom','?','?','Harmon min','?'],
	},
	{
		name: 'Double harmonic',
		pitches: [0, 1, 4, 5, 7, 8, 11],
		modes: ['Dbl harmon','Lydâ™¯2â™¯6','Ultraphryg','Hung minor','Oriental','Ionianâ™¯2â™¯6','Locrianð„«3ð„«7'],
	},
	{
		name: 'Neapolitan min',
		pitches: [0, 3, 4, 5, 7, 9, 11],
		modes: ['Neap min','?','?','Lyd min','?','?','?'],
	},
	{
		name: 'Neapolitan maj',
		pitches: [0, 1, 3, 5, 7, 9, 11],
		modes: ['Neap maj','?','?','?','Major Loc','?','?'],
	},
	{
		name: 'Enigmatic asc',
		pitches: [0, 1, 2, 5, 7, 9, 11],
		modes: ['?','Enig asc','?','?','?','?','?'],
	},
	{
		name: 'Enigmatic desc',
		pitches: [0, 1, 2, 5, 8, 9, 11],
		modes: ['?','Enig desc','?','?','?','?','?'],
	},
	{
		name: 'Octatonic',
		pitches: [0, 2, 3, 5, 6, 8, 9, 11],
		modes: ['WS/HS dim','Octatonic','WS/HS dim','Octatonic','WS/HS dim','Octatonic','WW/HS dim','Octatonic'],
	},
	{
		name: 'Bebop',
		pitches: [0, 2, 4, 5, 6, 7, 9, 11],
		modes: ['?','Bebop Dor','?','?','?','Bebop dom','?','?'],
	},
	{
		name: 'Bebop alt',
		pitches: [0, 1, 2, 4, 5, 7, 9, 11],
		modes: ['?','?','Alt Bb Dor','?','?','?','?','?'],
	},
	{
		name: 'Bebop harmonic',
		pitches: [0, 2, 4, 5, 7, 8, 9, 11],
		modes: ['Bebop maj','?','?','?','?','?','Bb har min','?'],
	},
	{
		name: 'Bebop melod',
		pitches: [0, 2, 3, 5, 7, 8, 9, 11],
		modes: ['Bb mel min','?','?','?','?','?','?','?'],
	},
	{
		name: 'Alex',
		pitches: [0, 1, 3, 4, 5, 7, 8, 9],
		modes: ['?','?','?','?','?','?','Alex','?'],
	},
	{
		name: 'Blues9',
		pitches: [0, 2, 3, 4, 5, 7, 9, 10, 11],
		modes: ['Blues9','?','?','?','?','?','?','?','?'],
	},
	{
		name: 'Chromatic',
		pitches: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
		modes: ['Chr','Chr','Chr','Chr','Chr','Chr','Chr','Chr','Chr','Chr','Chr','Chr'],
	}
];

function box(svg, x, y, w, h, fill, label) {
	return multibox(svg, x, y, w, h, fill, [{label,x:0,y:0}]);
}

function multibox(svg, x, y, w, h, fill, labels) {
	const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
	rect.setAttribute('x', x);
	rect.setAttribute('y', y);
	rect.setAttribute('width', w);
	rect.setAttribute('height', h);
	rect.setAttribute('fill', fill);
	rect.setAttribute('stroke', '#000');
	svg.appendChild(rect);

	for (const label of labels) {
		const text = document.createElementNS('http://www.w3.org/2000/svg','text');
		text.setAttribute('x', x + w / 2 + label.x);
		text.setAttribute('y', y + h / 2 + label.y);
		text.setAttribute('dominant-baseline', 'central');
		text.setAttribute('text-anchor', 'middle');
		text.setAttribute('fill', '#000');
		text.setAttribute('pointer-events', 'none');
		text.textContent = label.label;
		svg.appendChild(text);
	}

	return rect;
}

// sorry these are so ugly

/*
function scale_note_name(sig, mode, n) {
	let n_mod7 = ((n + (4 * mode) % 7) + 7) % 7;
	return note_names[6 + sig + lyd_scale_fifths[n_mod7]];
}

function scale_note_pitch(sig, mode, n) {
	let n_mod7 = ((n + (4 * mode) % 7) + 7) % 7;
	let t_mod7 = ((0 + (4 * mode) % 7) + 7) % 7;
	let pitch_class = (12 + (sig + lyd_scale_fifths[n_mod7]) * 7) % 12;
	let t_class     = (12 + (sig + lyd_scale_fifths[t_mod7]) * 7) % 12;
	let octave = Math.floor((n + 0.01) / 7);
	if (t_class > pitch_class) {
		octave++;
	}
	return pitch_class + octave * 12;
}
*/

function mod(a,b) {
	return ((a % b) + b) % b;
}

function div(a,b) {
	return Math.round((a - mod(a,b)) / b);
}

function full_key_name(pat, sig, mode) {
	let mode_name = scale_defs[pat].modes[mode];
	if (mode_name === '?') {
		mode_name = scale_defs[pat].name + '?' + mode;
	}
	return scale_note_name(pat, sig, mode, 0).name + ' ' + mode_name;
}

function scale_chord_quality(pat, mode, n) {
	let scale_len = scale_defs[pat].pitches.length;
	let mode_nclass = mod(mode + n, scale_len);
	let pitch_class = scale_defs[pat].pitches[mode_nclass];

	let fifth_class = mod(pitch_class + 7, 12);
	let minor_third_class = mod(pitch_class + 3, 12);
	let major_third_class = mod(pitch_class + 4, 12);

	const fifth = scale_defs[pat].pitches.indexOf(fifth_class) !== -1;
	const minor_third = scale_defs[pat].pitches.indexOf(minor_third_class) !== -1;
	const major_third = scale_defs[pat].pitches.indexOf(major_third_class) !== -1;

	if (fifth && major_third && minor_third) {
		return 'both';
	} else if (fifth && major_third) {
		return 'major';
	} else if (fifth && minor_third) {
		return 'minor';
	} else {
		return undefined;
	}
}

function scale_note_pitch(pat, sig, mode, n) {
	let scale_len = scale_defs[pat].pitches.length;
	let base = mod(sig * 7, 12);
	let mode_nclass = mod(mode + n, scale_len);
	let octave = div(mode + n, scale_len);
	return base + scale_defs[pat].pitches[mode_nclass] + 12 * octave;
}

function scale_note_name(pat, sig, mode, n) {
	let scale_len = scale_defs[pat].pitches.length;
	let mode_nclass = mod(mode + n, scale_len);
	let pitch_class = mod(sig * 7 + scale_defs[pat].pitches[mode_nclass], 12);
	let prev_pitch_class = mod(sig * 7 + scale_defs[pat].pitches[mod(mode_nclass-1,scale_len)], 12);
	let next_pitch_class = mod(sig * 7 + scale_defs[pat].pitches[mod(mode_nclass+1,scale_len)], 12);

	const diatonic = [0, 2, 4, 5, 7, 9, 11];
	//                    0   1    2   3    4   5   6    7   8    9   10   11
	const names_sharp = ['C','Câ™¯','D','Dâ™¯','E','F','Fâ™¯','G','Gâ™¯','A','Aâ™¯','B'];
	const names_flat  = ['C','Dâ™­','D','Eâ™­','E','F','Gâ™­','G','Aâ™­','A','Bâ™­','B'];
	const class_sharp = [ 0,  0,   1,  1,   2,  3,  3,   4,  4,   5,  5,   6];
	const class_flat  = [ 0,  1 ,  1,  2,   2,  3,  4,   4,  5,   5,  6,   6];

	// Use the key signature to guide whether we should write it as a sharp or a flat
	// But if it's sandwiched between D and F, write it as Eâ™­  not Dâ™¯
	let name = undefined;
	if (class_sharp[next_pitch_class] === class_flat[next_pitch_class] && class_sharp[next_pitch_class] === class_flat[pitch_class]) {
		name = names_sharp[pitch_class];
	} else if (class_sharp[prev_pitch_class] === class_flat[prev_pitch_class] && class_flat[prev_pitch_class] === class_sharp[pitch_class]) {
		name = names_flat[pitch_class];
	} else if (sig >= 0) {
		name = names_sharp[pitch_class];
	} else {
		name = names_flat[pitch_class];
	}

	let accidental = undefined;
	if (diatonic.indexOf(scale_defs[pat].pitches[mode_nclass]) === -1) {
		accidental = name;
		if (diatonic.indexOf(pitch_class) !== -1) {
			accidental += 'â™®';
		}
	}

	return {name, accidental};
}

function scale_pitch_class_inverse(pat, sig, mode, pitch_class) {
	let scale_len = scale_defs[pat].pitches.length;
	for (let n = 0; n < scale_len; n++) {
		if (mod(scale_note_pitch(pat,sig,mode,n) - pitch_class, 12) === 0) {
			return n;
		}
	}
	return undefined;
}

function click_pattern(e) {
	key_pat = parseInt(e.target.dataset.pat);
	init_key_menu();
}

function init_key_menu() {
	const svg = document.getElementById('key-menu');
	while (svg.lastChild) {
		svg.removeChild(svg.lastChild);
	}

	let chosen_y = 0;
	for (let pat = 0; pat < scale_defs.length; pat++) {
		let fill = '#fff';
		const y = pat * 30;
		if (pat === key_pat) {
			fill = '#cff';
			chosen_y = y + 15;
		}
		const rect = box(svg, 0, y, 200, 30, fill, scale_defs[pat].name);
		rect.dataset.pat = pat;
		rect.onclick = click_pattern;
	}
	const tri = document.createElementNS('http://www.w3.org/2000/svg','polygon');
	tri.setAttribute('fill','#fff');
	tri.setAttribute('stroke','#000');
	tri.setAttribute('points',`200,${chosen_y} 280,0 280,${14*45}`);
	svg.appendChild(tri);
	

	const scale_len = scale_defs[key_pat].pitches.length;
	const x0 = 280;
	const w = 800 / (scale_len + 1);
	const h = 45;
	box(svg, x0, 0, w, h, '#fff', 'Key sig');
	for (let mode = 0; mode < scale_len; mode++) {
		const quality = scale_chord_quality(key_pat, mode, 0);
		let fill = '#fff';
		if (quality === 'both') {
			fill = '#f8c';
		} else if (quality === 'major') {
			fill = '#fdd';
		} else if (quality === 'minor') {
			fill = '#cdf';
		}
		let mode_name = '?';
		if (scale_defs[key_pat].modes !== undefined) {
			mode_name = scale_defs[key_pat].modes[mode];
		}
		box(svg, x0 + (mode + 1) * w, 0, w, h, fill, mode_name);
	}
	for (let sig = -6; sig <= 6; sig++) {
		let labels = [];
		const sharp_ys = [3, 0, 4, 1, -2, 2, -1];
		const flat_ys = [0, 3, -1, 2, -2, 1];
		for (let i = 0; i < Math.abs(sig); i++) {
			if (sig < 0) {
				labels.push({
					label: 'â™­',
					x: i * 8 - 20,
					y: -flat_ys[i] * 4
				});
			} else {
				labels.push({
					label: 'â™¯',
					x: i * 8 - 20,
					y: -sharp_ys[i] * 4
				});
			}
			
		}
		multibox(svg, x0, (7 - sig) * h, w, h, '#fff', labels);

		for (let mode = 0; mode < scale_len; mode++) {
			let fill = '#fff';
			if (mode === key_mode && sig === key_sig) {
				fill = '#cff';
			} /*else if (mode === 1) {
				fill = '#fff4f4';
			} else if (mode === 4) {
				fill = '#f4f8ff';
			}*/
			let {name,accidental} = scale_note_name(key_pat, sig, mode, 0);
			if (accidental !== undefined) {
				fill = '#ccc';
			}
			let rect = box(svg, x0 + (mode + 1) * w, (7 - sig) * h, w, h, fill, name);
			rect.dataset.mode = mode;
			rect.dataset.sig = sig;
			rect.onclick = click_key;
		}
	}
}

function init_main() {
	const svg = document.getElementById('scale');
	const max_n = max_pitch + 12;  // should be enough labels
	for (let n = 0; n < max_n; n++) {
		const x = 0;
		
		const text = document.createElementNS('http://www.w3.org/2000/svg','text');
		text.setAttribute('x', x);
		text.setAttribute('y', 0); // set later
		text.setAttribute('font-size', 13);
		text.textContent = '';   // will be filled in later

		svg.appendChild(text);
	}
}

function update_chord_menu() {
	const svg = document.getElementById('chord-menu');
	while (svg.lastChild) {
		svg.removeChild(svg.lastChild);
	}

	if (key_pat === undefined || key_sig === undefined || key_mode === undefined || current_chord !== undefined) {
		return;
	}

	const h = 45;
	const tonic_pitch_class = scale_note_pitch(key_pat, key_sig, key_mode, 0);
	for (let i = 0; i < 12; i++) {
		const pitch_class = mod(tonic_pitch_class + i, 12);
		const y = (12 - i) * h;
		let n = scale_pitch_class_inverse(key_pat, key_sig, key_mode, pitch_class);
		if (n === undefined) {
			box(svg, 30, y, 45, h, '#888', '');
		} else {
			let name = scale_note_name(key_pat, key_sig, key_mode, n).name;
			let quality = scale_chord_quality(key_pat, key_mode, n);
			box(svg, 30, y, 45, h, '#fff', name);
			if (quality === 'both') {
				let rect = box(svg, 75, y, 60, h, '#fff', 'major');
				rect.dataset.root = pitch_class;
				rect.dataset.quality = 'major';
				rect.onclick = click_chord;
				rect = box(svg, 135, y, 60, h, '#fff', 'minor');
				rect.dataset.root = pitch_class;
				rect.dataset.quality = 'minor';
				rect.onclick = click_chord;
			} else if (quality !== undefined) {
				let rect = box(svg, 75, y, 120, h, '#fff', quality);
				rect.dataset.root = pitch_class;
				rect.dataset.quality = quality;
				rect.onclick = click_chord;
			}
		}
	}
}

function click_chord(e) {
	const root = parseInt(e.target.dataset.root);
	const quality = e.target.dataset.quality;
	if (quality === 'major') {
		current_chord = [root, mod(root + 4,12), mod(root + 7,12)];
	} else if (quality == 'minor') {
		current_chord = [root, mod(root + 3,12), mod(root + 7,12)];
	} else {
		current_chord = undefined;
	}

	let time = 0;
	if (events.length > 0) {
		time = events[events.length-1].time + 1;
	}

	if (current_chord !== undefined) {
		if (current_chord_index !== undefined) {
			events[current_chord_index].chord_end_time = time;
		}
		events.push({time, chord:current_chord});
		current_chord_index = events.length - 1;
	}
	update_display();
}

function init() {
	init_key_menu();
	init_main();
	update_display();
}

function update_staff() {
	const scale = document.getElementById('scale');
	const staff = document.getElementById('staff');
	while (staff.lastChild) {
		staff.removeChild(staff.lastChild);
	}
	let text_index = 0;
	let texts = scale.getElementsByTagName('text');
	let n = -12;
	const tonic_pitch_class = mod(scale_note_pitch(key_pat, key_sig, key_mode, 0), 12);
	while (true) {
		const pitch = scale_note_pitch(key_pat, key_sig, key_mode, n);
		if (pitch >= max_pitch) {
			break;
		}
		if (pitch >= 0) {
			const text = texts[text_index];
			if (text === undefined) {
				break;
			}
			text_index++;
			const y = 740 - 13 * pitch;
			const label = scale_note_name(key_pat, key_sig, key_mode, n).name;
			const pitch_class = pitch % 12;
			const is_tonic = pitch_class === tonic_pitch_class;
			text.setAttribute('y', y);
			text.setAttribute('dominant-baseline', 'central');
			text.setAttribute('fill', is_tonic ? '#f00' : '#000');
			text.textContent = label;
			text.classList.remove('hidden');
		}
		n++;
	}
	while (text_index < texts.length) {
		const text = texts[text_index];
		text.classList.add('hidden');
		text_index++;
	}
}

function update_notes() {
	const svg = document.getElementById('notes');
	while (svg.lastChild) {
		svg.removeChild(svg.lastChild);
	}
	for (const e of events) {
		const x = 40 + e.time * 10;
		if (e.pitch !== undefined) {
			const y = 740 - 13 * e.pitch;
			const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
			circle.setAttribute('cx', x);
			circle.setAttribute('cy', y);
			circle.setAttribute('r', 5);
			circle.setAttribute('fill', '#f00');
			svg.appendChild(circle);
		}
		if (e.chord !== undefined) {
			let n = -12;
			while (true) {
				const pitch = scale_note_pitch(key_pat, key_sig, key_mode, n);
				const y = 740 - 13 * pitch;
				if (pitch >= max_pitch) {
					break;
				}
				let pitch_class = mod(pitch, 12);
				if (current_chord !== undefined && e.chord.indexOf(pitch_class) !== -1) {
					const is_root = e.chord[0] === pitch_class;
					const line = document.createElementNS('http://www.w3.org/2000/svg','line');
					let x2 = 1000;
					if (e.chord_end_time !== undefined) {
						x2 = 40 + e.chord_end_time * 10;
					}
					line.setAttribute('x1', x);
					line.setAttribute('y1', y);
					line.setAttribute('x2', x2);
					line.setAttribute('y2', y);
					line.setAttribute('stroke',is_root ? '#f00' : '#000');
					line.setAttribute('pointer-events', 'none');
					svg.appendChild(line);
				}
				n++;
			}
		}
	}
}

function update_display() {
	const key_menu = document.getElementById('key-menu');
	const main = document.getElementById('main');
	const scale = document.getElementById('scale');
	const chord_menu = document.getElementById('chord-menu');

	if (key_sig === undefined || key_mode === undefined) {
		key_menu.classList.remove('hidden');
		main.classList.add('hidden');
		chord_menu.classList.add('hidden');
	} else {
		key_menu.classList.add('hidden');
		main.classList.remove('hidden');
		document.getElementById('key-name').textContent = 'Key: ' + full_key_name(key_pat, key_sig, key_mode);

		update_staff();
		update_chord_menu();
		update_notes();
		chord_menu.classList.remove('hidden');
	}
}

function click_key(e) {
	key_mode = parseInt(e.target.dataset.mode);
	key_sig = parseInt(e.target.dataset.sig);
	update_display();
}

function play_note(pitch) {
	let freq = c_hz * Math.pow(2, pitch / 12);
	init_audio();
	let i = 0;

	// Reuse an osc if possible
	for (let i = 0; i < max_osc_count; i++) {
		if (osc_pitches[i] === pitch) {
			oscs[i].frequency.setValueAtTime(freq, ctx.currentTime);
			gains[i].gain.cancelScheduledValues(ctx.currentTime);
			gains[i].gain.setValueAtTime(0.3, ctx.currentTime);
			gains[i].gain.linearRampToValueAtTime(0, ctx.currentTime + 0.5);
			silence_times[i] = ctx.currentTime + 0.5;
			return;
		}
	}

	while (true) {
		if (i >= max_osc_count) {
			const osc = ctx.createOscillator();
			osc.frequency.setValueAtTime(c_hz, ctx.currentTime);
			osc.start();

			const gain = ctx.createGain();
			gain.gain.setValueAtTime(0, ctx.currentTime);

			osc.connect(gain);
			gain.connect(ctx.destination);

			oscs.push(osc);
			gains.push(gain);
			silence_times.push(ctx.currentTime - 0.5);
			max_osc_count++;
		}
		if (silence_times[i] <= ctx.currentTime) {
			oscs[i].frequency.setValueAtTime(freq, ctx.currentTime);
			gains[i].gain.cancelScheduledValues(ctx.currentTime);
			gains[i].gain.setValueAtTime(0.3, ctx.currentTime);
			gains[i].gain.linearRampToValueAtTime(0, ctx.currentTime + 0.5);
			silence_times[i] = ctx.currentTime + 0.5;
			osc_pitches[i] = pitch;
			break;
		}
		i++;
	}
}

function init_audio() {
	if (ctx === undefined) {
		ctx = new AudioContext();
		oscs = [];
		gains = [];
		silence_times = [];
		osc_pitches = [];
	}
}

function svg_click(e) {
	const svg = document.getElementById('svg');
	const dim = svg.getBoundingClientRect();
	const x = e.clientX - dim.left;
	const y = e.clientY - dim.top;
	
	if (key_pat === undefined || key_sig === undefined || key_mode === undefined) {
		return;
	}
	let n = -12;
	let nearest_dist = 10000;
	let nearest_pitch = undefined;
	while (true) {
		const pitch = scale_note_pitch(key_pat, key_sig, key_mode, n);
		if (pitch >= max_pitch) {
			break;
		}
		if (pitch >= 0) {
			const pitch_y = 740 - 13 * pitch;
			if (Math.abs(pitch_y - y) < nearest_dist) {
				nearest_dist = Math.abs(pitch_y - y);
				nearest_pitch = pitch;
			}
		}
		n++;
	}

	if (nearest_pitch !== undefined) {
		if (events.length > 0 && events[events.length-1].pitch === undefined) {
			events[events.length-1].pitch = nearest_pitch;
		} else {
			let time = 0;
			if (events.length > 0) {
				time = events[events.length - 1].time + 1;
			}
			events.push({time, pitch:nearest_pitch});
			if (current_chord_index === undefined || time - events[current_chord_index].time >= beats_per_chord - 1) {
				current_chord = undefined;
			}
		}
		update_display();
	}
}

function play_timer() {
	const next_time = playing_time + 1;
	let finished = true;
	for (const e of events) {
		if (e.time >= playing_time && e.time < next_time) {
			if (e.pitch !== undefined) {
				play_note(e.pitch);
			}
		}
		if (e.time >= playing_time) {
			finished = false;
		}
	}
	playing_time = next_time;
	if (finished) {
		window.clearInterval(timer_handle);
		playing = false;
	}
}

function click_play(e) {
	playing_time = 0;
	if (!playing) {
		timer_handle = window.setInterval(play_timer, 400);
	}
}

window.onload = init;

	</script>
<style>
.hidden {
	display: none;
}
</style>
	<body>
		<svg width="1200" height="750" style="background:#eee" id="svg">
			<g id="key-menu"/>
			<g id="main">
				<text id="key-name" x="0" y="20"></text>
				<polygon points="200,0 220,15, 200,30" style="fill:#0c0" onclick="click_play(event)"/>
				<rect x="30" y="30" width="1000" height="700" style="fill:#ffd" onmousedown="svg_click(event)"/>
				<g id="scale"/>
				<g id="staff"/>
				<g id="notes"/>
			</g>
			<g id="chord-menu"/>
		</svg>
	</body>
</html>
